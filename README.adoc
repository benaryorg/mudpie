= Mudpie

:app: Mudpie


== Overview

{app} is a multi-threaded HTTP application server for the amazingly awesome
Rust language.  It is inspired by python's lean and elegant WSGI protocol.

{app} is written in 100% safe Rust code (no unsafe blocks), so it should
be quite reliable.  

{app} is not intended to be a front end server.  A front end, like nginx,
handles SSL termination and request/response buffering for slow clients, and
is typically event-driven for scalability.  


== Examples

Do +cargo run+ to start a toy server, running on +localhost:8000+.

[source,rust]
----
extern crate mudpie;
use mudpie::{WebServer, WebRequest, WebResponse};

fn get_hello_page(req: &WebRequest) -> WebResponse {
    let mut page = String::new();
    page.push_str("<h1>Hello World!</h1>");
    return WebResponse::new_html(page);
}

fn main() {
    let mut svr = WebServer::new();
    svr.add_path("/hello", get_hello_page);
    // Run with 10 worker threads
    svr.run("127.0.0.1", 8000, 10);
}
----


== Implementation


{app} has one main thread and N worker threads.  The main thread's only job is
to monitor the worker threads.  A higher level watchdog process, like systemd,
should monitor and restart the {app} process if it exits due to out of memory
or double panic (which should be very rare).

Each worker thread runs an independent connection processing loop, which calls
+accept()+ on its own copy of the listening socket.  The main thread is not
bothered and there is no overhead of context switching between threads.  Also,
there is no "bufferbloat" of connections piling up in a queue.

NOTE: On Linux kernels >= 3.9, the SO_REUSEPORT option could be used for even
more scalable processing.  Shared-nothing threads are "the new prefork".

If a worker thread panics, it will attempt to send a 500 Internal Error if a
response had not yet been started.  Then the worker thread will be destroyed.

The main thread will notice a dead worker thread immediately (a condition
variable is used), and then spawn a replacement worker thread.

If the main thread panics (e.g. because spawning a new worker fails), or a
double panic happens in a worker thread, the entire process will abort.  This
is standard Rust behavior.



== Routing

{app} has a simple goal: route path patterns to user-specified processing
functions.  


== License

Public Domain.  
